# WBS-005 Booking, Checkout, and Payment Processing GraphQL Contract

enum LegType {
  TALENT
  STUDIO
}

enum LegStatus {
  DRAFT
  AWAITING_DOCS
  AWAITING_PAYMENT
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  FAILED
}

enum LbgStatus {
  DRAFT
  AWAITING_DOCS
  AWAITING_PAYMENT
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  FAILED
}

enum ChargeStatus {
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURED
  SUCCEEDED
  CANCELED
  FAILED
}

enum DepositStatus {
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURED
  VOIDED
  EXPIRED
}

enum DepositClaimStatus {
  PENDING
  APPROVED
  DENIED
  CAPTURED
  VOIDED
}

enum PayoutStatus {
  QUEUED
  IN_TRANSIT
  PAID
  FAILED
  CANCELED
  PAUSED
}

enum RefundStatus {
  PENDING
  SUCCEEDED
  FAILED
}

enum DisputeStatus {
  NEEDS_RESPONSE
  UNDER_REVIEW
  WON
  LOST
  WARNING_CLOSED
}

enum ReserveStatus {
  HELD
  PENDING_RELEASE
  RELEASED
  FORFEITED
}

enum FinanceCloseStatus {
  OPEN
  IN_PROGRESS
  SUCCEEDED
  FAILED
}

enum PaymentMethodKind {
  CARD
  ACH_DEBIT
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  EXPIRED
}

enum ApprovalDecision {
  APPROVE
  REJECT
  CANCEL
}

enum DocPackStatus {
  DRAFT
  ISSUED
  SIGNED
  VOIDED
  SUPERSEDED
}

enum DocEnvelopeStatus {
  NONE
  SENT
  COMPLETED
  VOIDED
  EXPIRED
}

input DateTimeRangeInput {
  start: AWSDateTime!
  end: AWSDateTime!
}

input StartCheckoutInput {
  leg: StartLegInput!
  when: DateTimeRangeInput!
  city: String!
  mode: String! # IB, RTB, SMART_INVITE
  correlationId: String
}

input StartLegInput {
  type: LegType!
  sellerUserId: ID!
  serviceProfileId: ID
  studioId: ID
  title: String!
  subtotalCents: Int!
  taxCents: Int = 0
  feesCents: Int = 0
  currency: String = "USD"
  policy: AWSJSON!
}

input AttachStudioInput {
  draftId: ID!
  studioId: ID!
  correlationId: String
}

input CreateDocPackInput {
  draftId: ID!
  legId: ID!
  generatorVersion: String!
  city: String
  forceReissue: Boolean = false
}

input MarkDocSignedInput {
  draftId: ID!
  packId: ID!
  envelopeId: ID!
  actorContext: String
}

input PaymentMethodInput {
  kind: PaymentMethodKind!
  paymentMethodId: ID
  customerId: ID
  saveForFutureUse: Boolean = false
  billingDetails: AWSJSON
}

input CreatePaymentIntentInput {
  draftId: ID!
  method: PaymentMethodInput!
  idempotencyKey: String!
}

input ChangeOrderInput {
  lbgId: ID!
  legId: ID!
  name: String!
  quantity: Int = 1
  unitPriceCents: Int!
  notes: String
}

input OvertimeInput {
  lbgId: ID!
  legId: ID!
  minutes: Int!
}

input QuoteCancellationInput {
  lbgId: ID!
  legId: ID!
}

input CancelLegInput {
  lbgId: ID!
  legId: ID!
  reason: String!
  actorContext: String
  override: AWSJSON
}

input RefundRequestInput {
  lbgId: ID!
  legId: ID!
  amountCents: Int
  reason: String!
  metadata: AWSJSON
}

input DepositClaimInput {
  legId: ID!
  amountCents: Int!
  reason: String!
  evidence: [AWSURL!]
}

type CheckoutLeg {
  legId: ID!
  type: LegType!
  status: LegStatus!
  title: String!
  startAt: AWSDateTime!
  endAt: AWSDateTime!
  subtotalCents: Int!
  taxCents: Int!
  feesCents: Int!
  totalCents: Int!
  currency: String!
  policy: AWSJSON!
  docPackId: ID
  buyerAcceptsDocs: Boolean!
}

type CheckoutDraft {
  lbgId: ID!
  status: LbgStatus!
  city: String!
  legs: [CheckoutLeg!]!
  requiresDocs: Boolean!
  docsSigned: Boolean!
  paymentIntentId: ID
  paymentClientSecret: String
  totalCents: Int!
  currency: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type DocSignerLink {
  role: String!
  url: AWSURL!
  expiresAt: AWSDateTime
}

type DocEnvelope {
  envelopeId: ID!
  docId: ID!
  status: DocEnvelopeStatus!
  signerLinks: [DocSignerLink!]!
  completedAt: AWSDateTime
  voidedAt: AWSDateTime
  hashPreSign: String
  hashPostSign: String
}

type DocManifestEntry {
  docId: ID!
  templateId: ID!
  templateVersion: Int!
  envelopeStatus: DocEnvelopeStatus!
  renderPdfSha256Pre: String
  renderPdfSha256Post: String
}

type DocPack {
  packId: ID!
  lbgId: ID!
  legId: ID!
  status: DocPackStatus!
  generatorVersion: String!
  city: String!
  manifest: [DocManifestEntry!]!
  envelopes: [DocEnvelope!]!
  issuedAt: AWSDateTime
  signedAt: AWSDateTime
  supersededBy: ID
  wormRetainedUntil: AWSDateTime!
  legalHold: Boolean!
}

type PaymentIntentClientSecret {
  paymentIntentId: ID!
  clientSecret: String!
  status: ChargeStatus!
  requiresAction: Boolean!
  nextAction: AWSJSON
}

type ChargeSummary {
  chargeId: ID!
  status: ChargeStatus!
  amountCents: Int!
  currency: String!
  paymentMethod: PaymentMethodKind
  processorIntent: String!
  capturedAt: AWSDateTime
}

type DepositSummary {
  depositId: ID!
  status: DepositStatus!
  authorizedCents: Int!
  capturedCents: Int!
  expiresAt: AWSDateTime
  claimWindowExpiresAt: AWSDateTime
}

type PayoutSummary {
  payoutId: ID!
  status: PayoutStatus!
  amountCents: Int!
  currency: String!
  scheduledFor: AWSDateTime
  reserveHoldCents: Int!
  instantPayoutEligible: Boolean!
}

type LinkedBookingGroup {
  lbgId: ID!
  status: LbgStatus!
  city: String!
  startAt: AWSDateTime!
  endAt: AWSDateTime!
  acceptanceUntil: AWSDateTime
  currency: String!
  legs: [CheckoutLeg!]!
  charge: ChargeSummary
  deposits: [DepositSummary!]!
  payouts: [PayoutSummary!]!
  reserves: [ReserveEntry!]!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CheckoutConfirmation {
  lbg: LinkedBookingGroup!
  charge: ChargeSummary!
  correlationId: String!
}

type Amendment {
  amendmentId: ID!
  legId: ID!
  kind: String!
  line: AWSJSON!
  deltaSubtotalCents: Int!
  deltaTaxCents: Int!
  deltaFeesCents: Int!
  deltaTotalCents: Int!
  createdBy: ID!
  createdAt: AWSDateTime!
}

type RefundOutcome {
  legId: ID!
  refundCents: Int!
  sellerRetainedCents: Int!
  taxRefundCents: Int!
  policyVersion: Int
  overrideApplied: Boolean!
}

type RefundReceipt {
  refundId: ID!
  status: RefundStatus!
  amountCents: Int!
  processor: String!
  processorRefundId: String
  createdAt: AWSDateTime!
}

type DepositClaimResult {
  claimId: ID!
  legId: ID!
  amountCents: Int!
  deposit: DepositSummary!
  capturedCents: Int!
  status: DepositClaimStatus!
  reason: String!
  evidence: [AWSURL!]!
  approvedBy: ID
  decisionReason: String
  decidedAt: AWSDateTime
}

type ReceiptLeg {
  legId: ID!
  title: String!
  totalCents: Int!
  taxCents: Int!
  feesCents: Int!
  currency: String!
  policy: AWSJSON!
  amendments: [Amendment!]!
  refunds: [RefundReceipt!]!
}

type CompletionReceipt {
  lbgId: ID!
  status: LbgStatus!
  legs: [ReceiptLeg!]!
  charge: ChargeSummary!
  issuedAt: AWSDateTime!
  docHashes: [String!]!
}

type ReservePolicy {
  policyId: ID!
  sellerUserId: ID!
  reserveBps: Int!
  minimumCents: Int!
  rollingDays: Int!
  instantPayoutEnabled: Boolean!
  updatedAt: AWSDateTime!
  createdAt: AWSDateTime!
}

type ReserveEntry {
  entryId: ID!
  sellerUserId: ID!
  legId: ID
  payoutId: ID
  status: ReserveStatus!
  reserveCents: Int!
  releaseAfter: AWSDateTime
  releasedAt: AWSDateTime
  notes: String
}

type DisputeEvidence {
  kind: String!
  label: String
  url: AWSURL
  content: String
  capturedAt: AWSDateTime
}

type DisputeDetail {
  disputeId: ID!
  legId: ID!
  status: DisputeStatus!
  reason: String!
  evidenceDueAt: AWSDateTime
  evidence: [DisputeEvidence!]!
}

type FinanceCloseItem {
  itemId: ID!
  category: String!
  expectedCents: Int
  actualCents: Int
  varianceCents: Int
  context: AWSJSON!
}

type FinanceDailyClose {
  closeId: ID!
  closeDate: AWSDate!
  status: FinanceCloseStatus!
  varianceCents: Int!
  varianceSummary: AWSJSON!
  startedAt: AWSDateTime!
  completedAt: AWSDateTime
  actorAdmin: ID
  items: [FinanceCloseItem!]!
}

type FinanceApprovalDecision {
  decisionId: ID!
  approver: ID!
  decision: ApprovalDecision!
  reason: String
  decidedAt: AWSDateTime!
}

type FinanceApprovalRequest {
  approvalId: ID!
  scope: String!
  referenceId: ID!
  status: ApprovalStatus!
  approvalsRequired: Int!
  approvalsObtained: Int!
  context: AWSJSON!
  reason: String
  createdBy: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  expiresAt: AWSDateTime
  decisions: [FinanceApprovalDecision!]!
}

type FinanceActionLog {
  logId: ID!
  approval: FinanceApprovalRequest
  action: String!
  subjectReference: ID
  beforeState: AWSJSON
  afterState: AWSJSON
  metadata: AWSJSON
  decision: FinanceApprovalDecision
  approvalSnapshot: FinanceApprovalRequest
  actorAdmin: ID!
  reason: String
  createdAt: AWSDateTime!
}

input OverrideReservePolicyInput {
  sellerUserId: ID!
  reserveBps: Int!
  minimumCents: Int = 0
  rollingDays: Int = 0
  instantPayoutEnabled: Boolean = false
  idempotencyKey: String!
}

input ReleaseReserveInput {
  entryId: ID!
  idempotencyKey: String!
  reason: String
}

input QueuePayoutInput {
  lbgId: ID!
  idempotencyKey: String!
}

input SubmitDisputeEvidenceInput {
  disputeId: ID!
  evidence: [AWSJSON!]
  narrative: String!
  idempotencyKey: String!
}

input StartDailyCloseInput {
  closeDate: AWSDate!
  idempotencyKey: String!
}

input StartFinanceApprovalInput {
  scope: String!
  referenceId: ID!
  context: AWSJSON
  reason: String
  approvalsRequired: Int = 2
  expiresInHours: Int
  idempotencyKey: String!
}

input DecideFinanceApprovalInput {
  approvalId: ID!
  decision: ApprovalDecision!
  reason: String
  idempotencyKey: String!
}

type CheckoutEvent {
  lbgId: ID!
  eventType: String!
  payload: AWSJSON!
  occurredAt: AWSDateTime!
}

type BookingError {
  code: String!
  message: String!
  hint: String
  correlationId: String!
  recoverable: Boolean!
}

extend type Query {
  booking(lbgId: ID!): LinkedBookingGroup! @auth(role: "user")
  bookingTimeline(lbgId: ID!): [CheckoutEvent!]! @auth(role: "user")
  docPack(packId: ID!): DocPack! @auth(role: "user")
  docPacks(lbgId: ID!): [DocPack!]! @auth(role: "user")
  financeBooking(lbgId: ID!): LinkedBookingGroup! @auth(role: "finance_ops")
  financeReserveLedger(sellerUserId: ID!): [ReserveEntry!]! @auth(role: "finance_ops")
  financeDailyClose(date: AWSDate!): FinanceDailyClose! @auth(role: "finance_ops")
  financeApproval(approvalId: ID!): FinanceApprovalRequest! @auth(role: "finance_ops")
  financeApprovalRequests(status: [ApprovalStatus!], scope: String, limit: Int = 25): [FinanceApprovalRequest!]! @auth(role: "finance_ops")
  financeActionLog(approvalId: ID!, limit: Int = 50): [FinanceActionLog!]! @auth(role: "finance_ops")
  trustDispute(disputeId: ID!): DisputeDetail! @auth(role: "trust_safety")
}

extend type Mutation {
  startCheckout(input: StartCheckoutInput!): CheckoutDraft! @auth(role: "user") @rateLimit(name: "checkout", window: "PT1M", max: 10)
  attachStudioInFlow(input: AttachStudioInput!): CheckoutDraft! @auth(role: "user")
  createDocPack(input: CreateDocPackInput!): DocPack! @auth(role: "user")
  markDocSigned(input: MarkDocSignedInput!): DocPack! @auth(role: "user")
  createPaymentIntent(input: CreatePaymentIntentInput!): PaymentIntentClientSecret! @auth(role: "user")
  confirmPayment(draftId: ID!, idempotencyKey: String!): CheckoutConfirmation! @auth(role: "user")
  addChangeOrder(input: ChangeOrderInput!): Amendment! @auth(role: "user")
  addOvertime(input: OvertimeInput!): Amendment! @auth(role: "user")
  quoteCancellation(input: QuoteCancellationInput!): RefundOutcome! @auth(role: "user")
  cancelLeg(input: CancelLegInput!): RefundReceipt! @auth(role: "user")
  requestRefund(input: RefundRequestInput!): RefundOutcome! @auth(role: "user")
  fileDepositClaim(input: DepositClaimInput!): DepositClaimResult! @auth(role: "seller")
  approveDepositClaim(claimId: ID!, amountCents: Int!, decisionReason: String, idempotencyKey: String!): DepositClaimResult! @auth(role: "finance_ops")
  denyDepositClaim(claimId: ID!, decisionReason: String, idempotencyKey: String!): DepositClaimResult! @auth(role: "finance_ops")
  voidDepositClaim(claimId: ID!, decisionReason: String, idempotencyKey: String!): DepositClaimResult! @auth(role: "finance_ops")
  markCompleted(lbgId: ID!, note: String): CompletionReceipt! @auth(role: "user")
  overrideReservePolicy(input: OverrideReservePolicyInput!): ReservePolicy! @auth(role: "finance_ops")
  releaseReserveHold(input: ReleaseReserveInput!): ReserveEntry! @auth(role: "finance_ops")
  queuePayouts(input: QueuePayoutInput!): [PayoutSummary!]! @auth(role: "finance_ops")
  submitDisputeEvidence(input: SubmitDisputeEvidenceInput!): DisputeDetail! @auth(role: "trust_safety")
  startFinanceDailyClose(input: StartDailyCloseInput!): FinanceDailyClose! @auth(role: "finance_ops")
  startFinanceApproval(input: StartFinanceApprovalInput!): FinanceApprovalRequest! @auth(role: "finance_ops")
  decideFinanceApproval(input: DecideFinanceApprovalInput!): FinanceApprovalRequest! @auth(role: "finance_ops")
}

extend type Subscription {
  checkoutStatus(lbgId: ID!): CheckoutEvent! @aws_subscribe(mutations: ["confirmPayment", "markCompleted", "cancelLeg", "requestRefund"])
}
