<!-- id: TD-0340 | source: ProjectPlans\TechnicalDevelopmentPlan.odt | range: 1224000-1228000 -->

                    userId                         **20 / 10 rpm / 60s**
  **Checkout create/confirm**                                          userId                         **20 / 10 rpm / 60s** AND **100/day**
  **Partner REST** */v1/\**                                            **clientId (API key/OAuth)**   **1200 / 600 rpm / 60s** (tiered plans)
  **Webhooks (inbound)** Stripe, etc.                                  provider IP range              **No app throttle** (accept all); rely on queue/DLQ; WAF allowlist
  -------------------------------------------------------------------- ------------------------------ --------------------------------------------------------------------

Messaging + Suggestions also have **Appendix U** abuse rules
(shadow/mute escalation) beyond pure rate.

## **R.2 Headers (always return on REST & GraphQL)**

- ***X-RateLimit-Limit***: total tokens available for the current window
  for this key.
- ***X-RateLimit-Remaining***: tokens remaining **after** this request.
- ***X-RateLimit-Reset***: UTC epoch seconds when the bucket refills to
  the limit.
- On throttle: **HTTP 429** with ***Retry-After: \<seconds\>*** and
  error body (Appendix J shape).

**429 example**

*HTTP/1.1 429 Too Many Requests*\
*Content-Type: application/json*\
*Retry-After: 30*\
*X-RateLimit-Limit: 60*\
*X-RateLimit-Remaining: 0*\
*X-RateLimit-Reset: 1730892000*\
\
*{*\
*\"error\": {*\
*\"code\": \"rate_limit_exceeded\",*\
*\"message\": \"Too many requests. Try again in 30 seconds.\",*\
*\"traceId\": \"01HFQ...\",*\
*\"limits\": { \"limit\": 60, \"remaining\": 0, \"reset\": 1730892000
}*\
*}*\
*}*\

**GraphQL**: return the same headers on the HTTP response; if throttling
within a batched operation, fail the operation with a top‑level error
using *extensions.code=\"RATE_LIMITED\"*.

## **R.3 Algorithms & storage**

**Primary**: **Token bucket** (burst tolerant).

- State per **key**: *allowance (float)*, *last_ts* (ms), *limit*,
  *refill_per_sec*.
- Persist in **DynamoDB** table *rate_limits* (low‑cost, conditional
  writes).
- Optional **in‑memory cache** (Lambda ephemeral cache for hot keys for
  a few seconds) to cut write QPS.

**DynamoDB table**: *rate_limits*

- **PK**: *key* (e.g., *ip#1.2.3.4#search*, *user#123#msg.send*,
  *dyad#u1:u2#msg.send*, *client#abc#rest.v1*)
- **Attributes**: *allowance* (N), *last_ts* (N, epoch ms), *limit* (N),
  *refill* (N tokens/sec), *reset* (N epoch sec), *updated_at* (N)
- **TTL**: optional (e.g., 24h) to auto‑prune cold keys.

## **R.4 Edge & Gateway configuration**

### **R.4.1 WAF (edge) --- rate‑based + bot control**

**Examples** (JSON snippets live at *ops/waf/rate_rules.json*):

- **Search endpoints** */api/search/\**: **3,000 req/5m per IP** block
  at edge (cheap).
- **Suggest endpoints** */api/suggest/\**: **1,000 req/5m**.
- **Auth endpoints** */auth/\**: tighter burst rules; CAPTCHA trigger
  (Appendix U).

(We already included a full example in Appendix U; reuse and tune the
numbers above.)

### **R.4.2 API Gateway (Partner REST)**

If Partner REST runs on API Gateway, use **Usage Plans** per API key (or
OAuth client) with per‑key ***rate*** and ***burst***; add WAF as well.

**CDK sketch** (*infra/cdk/partner-api.ts*):

*const plan = api.addUsagePlan(\'DefaultPlan\', {*\
*throttle: { rateLimit: 600, burstLimit: 120 }, // per key*\
*quota: { limit: 50000, period: apigw.Period.DAY }*\
*});*\
*plan.addApiKey(key); plan.addApiStage({ stage: api.deploymentStage
});*\

**Mapping to headers**: API Gateway emits *x-rate-limit-\** internally;
otherwise, your Lambda returns the standard headers in R.2.

### **R.4.3 AppSync (GraphQL)**

Use a **pre‑resolver** function to enforce per‑field/operation limits
(cheap, consistent).

**AppSync JS function** *api/functions/rateGuard.js*

*import { DynamoDBClient, UpdateItemCommand, GetItemCommand } from
\"@aws-sdk/client-dynamodb\";*\
*const ddb = new DynamoDBClient({});*\
*const TABLE = process.env.RATE_TABLE;*\
\
*function bucket(