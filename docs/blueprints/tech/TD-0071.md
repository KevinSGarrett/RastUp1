<!-- id: TD-0071 | source: ProjectPlans\TechnicalDevelopmentPlan.odt | range: 255600-259600 -->

":\".../payout.paid.v1.json\",*\
*\"type\":\"object\",*\
*\"required\":\[\"leg_id\",\"amount_cents\",\"provider_ref\"\],*\
*\"properties\":{*\
*\"leg_id\":{\"type\":\"string\"},*\
*\"amount_cents\":{\"type\":\"integer\",\"minimum\":0},*\
*\"provider_ref\":{\"type\":\"string\"}*\
*}*\
*}*\

**Versioning:** Backward‑compatible field additions do not bump *v*;
breaking changes → new schema id and *v+1* in envelope.

## **1.13.B & 1.13.E (expanded) --- Ingestion, Bronze, and Near‑Real‑Time Views**

### **B.1 Event ingress path**

- **Client events**: App/Web → AppSync mutation *publishEvent* → Lambda
  *evt_ingest*:

  - Validate against **envelope schema** + **event‑specific schema**
    (ajv).
  - Add server fields (*received_at*, *context.env*, *ua_hash*).
  - Put onto **EventBridge Bus** (*rastup-events*).

- **Backend events**: services publish directly to EventBridge with the
  same envelope contract.

- **Provider webhooks** (Stripe, e‑sign, SES): normalized in dedicated
  Lambdas and published to EventBridge.

### **B.2 EventBridge → Firehose → S3 (Bronze)**

- Kinesis Firehose (Direct PUT from EventBridge)

  - **Buffer size**: 5 MB or **buffer interval** 60 s (whichever first).
  - **Compression**: GZIP.
  - **Dynamic partitioning** via record transformation Lambda to set S3
    prefix:

*s3://data/bronze/events/dt=YYYY-MM-DD/hour=HH/env=\${env}/event=\${event}/*\

- - **Backup**: All failures to *s3://data/bronze/\_bad/...*
    (quarantine) with original payload + error.
- **S3 object key** example:\
  *.../dt=2025-11-06/hour=15/env=prod/event=lbg.confirmed/part-00023-...json.gz*

### **B.3 Glue Catalog & Athena (Bronze table)**

*CREATE EXTERNAL TABLE IF NOT EXISTS bronze_events (*\
*event string,*\
*v int,*\
*occurred_at timestamp,*\
*received_at timestamp,*\
*user_id string,*\
*anon_id string,*\
*session_id string,*\
*city string,*\
*device struct\<ua_hash:string, os:string, app_ver:string\>,*\
*context struct\<role:string, env:string\>,*\
*ids map\<string,string\>,*\
*money struct\<amount_cents:int, currency:string\>,*\
*payload string \-- keep raw JSON; parse in Silver*\
*)*\
*PARTITIONED BY (dt string, hour string, env string, event_name
string)*\
*ROW FORMAT SERDE \'org.openx.data.jsonserde.JsonSerDe\'*\
*LOCATION \'s3://data/bronze/events/\'*\
*TBLPROPERTIES (\'projection.enabled\'=\'true\');*\

**Note:** Use **partition projection** to avoid expensive *MSCK REPAIR*.
For Firehose prefixes, set *event_name* from *event* value.

### **E.1 Near‑Real‑Time (NRT) Ops Views**

- Use **Athena CTAS** every 5--10 min to create small **Parquet**
  materializations for Admin dashboards.

**Example: payout backlog by city (last 24h)**

*CREATE TABLE IF NOT EXISTS ops_payout_backlog*\
*WITH (*\
*format=\'PARQUET\',*\
*parquet_compression=\'SNAPPY\',*\
*partitioned_by=array\[\'dt\'\]*\
*) AS*\
*SELECT*\
*date_format(received_at, \'%Y-%m-%d\') AS dt,*\
*coalesce(b.payload_json.city, \'unknown\') AS city,*\
*count_if(b.event=\'payout.queued\') AS queued,*\
*count_if(b.event=\'payout.paid\') AS paid,*\
*count_if(b.event=\'payout.failed\') AS failed,*\
*(count_if(b.event=\'payout.queued\') -
count_if(b.event=\'payout.paid\')) AS backlog*\
*FROM (*\
*SELECT*\
*event,*\
*received_at,*\
*json_parse(payload) AS payload_json*\
*FROM bronze_events*\
*WHERE dt \>= date_format(date_add(\'day\', -1, current_date),
\'%Y-%m-%d\')*\
*AND env=\'prod\'*\
*) b*\
*GROUP BY 1,2;*\

Schedule via **Athena Scheduler** or a small **Step Functions** state
machine.

## **1.13.D (expanded) --- Silver/Gold Modeling**

### **D.1 CTAS: Silver facts (examples)**

- Search impressions (Silver)

*CREATE TABLE IF NOT EXISTS silver.fact_search_impressions*\
*WITH (format=\'PARQUET\', parquet_compression=\'SNAPPY\',
partitioned_by=array\[\'dt\'\]) AS*\
*SELECT*\
*date_format(received_at, \'%Y-%m-%d\') AS dt,*\
*received_at,*\
*coalesce(user_id, anon_id) AS actor_key,*\
*(payload_json -\>\> \'query_hash\') AS query_hash,*\
*(payload_json -\>\> \'result_pos\')::int