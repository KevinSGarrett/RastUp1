<!-- id: TD-0134 | source: ProjectPlans\TechnicalDevelopmentPlan.odt | range: 482400-486400 -->

ent* (JSON; text markdown subset for *TEXT*)
- *attachments* (\[{*key*,*mime*,*bytes*,*hash*,*thumbKey*}\]) ---
  presigned S3 keys
- *action* (nullable Action Card payload; see §1.23.6)
- *stateChange* ({*type*: *READ\|DELIVERED\|TYPING_ON\|TYPING_OFF*,
  *targets*:\[userId\]})
- *safeModeBand* (int *0\|1\|2* for preview gating)
- *spamScore* (float), *policyTags* (\[*HARASSMENT\|DOXXING\|NSFW*...\])
  --- for triage routing.

NonTechBlueprint_Part3

- GSIs:

  - *gsiUserThreads* (PK=*userId*, SK=*lastMessageAt* desc) for inbox
    list
  - *gsiSearch* (PK=*threadId*, SK=*textIndex*) optional if we keep
    Typesense as the search frontend

### **1.23.2.2 Aurora (relational join & analytics)**

**Tables:**

- thread_index(thread_id pk, booking_id, role_context, created_at)
- message_audit(message_id pk, thread_id fk, sender_id, ts, kind,
  safe_band, policy_tags)
- *message_credit_ledger(user_id, period, granted, spent, carryover)*
  --- supports "New conversation credits (monthly) ... Unlimited replies
  in existing threads."

NonTechBlueprint

Rationale: DynamoDB handles hot paths (inbox reads, message fan‑out).
Aurora preserves joins with bookings/contracts and provides durable
audit/reporting.

## **1.23.3 GraphQL Schema (AppSync)**

**Recommended path:** *api/schema/messaging.graphql*

*enum ThreadType { INQUIRY INVITE BOOKING DISPUTE SYSTEM }*\
*enum ThreadStatus { OPEN AWAITING_REPLY PENDING_DECISION CONFIRMED
COMPLETED DISPUTED ARCHIVED }*\
*enum MessageKind { TEXT ATTACHMENT ACTION SYSTEM STATE }*\
\
*type Thread {*\
*threadId: ID!*\
*type: ThreadType!*\
*roleContext: String!*\
*participants: \[ID!\]!*\
*bookingId: ID*\
*status: ThreadStatus!*\
*lastMessageAt: AWSDateTime!*\
*unreadCount: Int!*\
*project: ProjectPanel*\
*requestState: String*\
*}*\
\
*type Message {*\
*messageId: ID!*\
*threadId: ID!*\
*senderId: ID!*\
*ts: AWSDateTime!*\
*kind: MessageKind!*\
*text: String*\
*attachments: \[Attachment!\]*\
*action: ActionCard*\
*}*\
\
*type Attachment { key: String!, mime: String!, bytes: Int!, thumbKey:
String }*\
*type ProjectPanel {*\
*packageId: ID*\
*schedule: AWSJSON*\
*location: AWSJSON*\
*callSheet: AWSJSON*\
*contracts: \[ID!\]*\
*deliverables: AWSJSON*\
*payments: AWSJSON*\
*}*\
\
*union ActionCard = ProposeTime \| Reschedule \| AddExtras \| Overtime
\| UploadProofs \| RequestApproval \| ExpenseReceipt \| MarkCompleted \|
OpenDispute \| ShareLocation \| SafetyFlag*\
*type ProposeTime { start: AWSDateTime!, end: AWSDateTime!, timezone:
String! }*\
*type Reschedule { reason: String!, options: \[ProposeTime!\]! }*\
*type AddExtras { items: \[ExtraInput!\]! }*\
*input ExtraInput { sku: ID!, qty: Int! }*\
*type Overtime { minutes: Int!, rateCents: Int! }*\
*type UploadProofs { files: \[Attachment!\]! }*\
*type RequestApproval { assetIds: \[ID!\]!, due: AWSDateTime }*\
*type ExpenseReceipt { amountCents: Int!, memo: String!, attachment:
Attachment }*\
*type MarkCompleted { note: String }*\
*type OpenDispute { reason: String!, detail: String }*\
*type ShareLocation { lat: Float!, lon: Float!, until: AWSDateTime }*\
*type SafetyFlag { category: String!, note: String }*\
\
*type Query {*\
*inbox(folder: String, after: String, limit: Int = 30): \[Thread!\]!*\
*thread(threadId: ID!): Thread!*\
*messages(threadId: ID!, after: String, limit: Int = 50):
\[Message!\]!*\
*}*\
\
*type Mutation {*\
*startConversation(toUserId: ID!, roleContext: String!, bookingId: ID,
firstMessage: String!): Thread!*\
*sendMessage(threadId: ID!, kind: MessageKind!, text: String,
attachments: \[AttachmentInput!\], action: AWSJSON): Message!*\
*setTyping(threadId: ID!, on: Boolean!): Boolean!*\
*markRead(threadId: ID!, upToTs: AWSDateTime!): Boolean!*\
*acceptRequest(threadId: ID!): Boolean!*\
*declineRequest(threadId: ID!, reason: String): Boolean!*\
*blockUser(userId: ID!, reason: String): Boolean!*\
*reportMessage(messageId: ID!, reason: String!, detail: String):
Boolean!*\
*}*\
\
*input AttachmentInput { key: String!, mime: String!, bytes