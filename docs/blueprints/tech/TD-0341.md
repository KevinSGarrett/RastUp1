<!-- id: TD-0341 | source: ProjectPlans\TechnicalDevelopmentPlan.odt | range: 1227600-1231600 -->

ndard headers in R.2.

### **R.4.3 AppSync (GraphQL)**

Use a **pre‑resolver** function to enforce per‑field/operation limits
(cheap, consistent).

**AppSync JS function** *api/functions/rateGuard.js*

*import { DynamoDBClient, UpdateItemCommand, GetItemCommand } from
\"@aws-sdk/client-dynamodb\";*\
*const ddb = new DynamoDBClient({});*\
*const TABLE = process.env.RATE_TABLE;*\
\
*function bucket(now, key, limit, refillPerSec) {*\
*return { key, limit, refill: refillPerSec, now };*\
*}*\
\
*async function consume(b, tokens=1) {*\
*const now = b.now;*\
*// Fetch current*\
*const get = await ddb.send(new GetItemCommand({*\
*TableName: TABLE, Key: { key: { S: b.key } }*\
*}));*\
*let allowance = b.limit;*\
*let last = now;*\
*if (get.Item) {*\
*allowance = parseFloat(get.Item.allowance.N);*\
*last = parseInt(get.Item.last_ts.N, 10);*\
*}*\
*// Refill*\
*allowance = Math.min(b.limit, allowance + ( (now - last) / 1000.0 ) \*
b.refill);*\
*const remaining = allowance - tokens;*\
*if (remaining \< 0) return { ok:false, remaining:
Math.floor(Math.max(0, allowance)), reset: Math.ceil(now/1000 +
(tokens - allowance)/b.refill) };*\
\
*// Commit (conditional to avoid races)*\
*await ddb.send(new UpdateItemCommand({*\
*TableName: TABLE,*\
*Key: { key: { S: b.key } },*\
*UpdateExpression: \"SET allowance = :a, last_ts = :t, #u = :u, #r =
:r\",*\
*ExpressionAttributeValues: {*\
*\":a\": { N: remaining.toFixed(3) },*\
*\":t\": { N: String(now) },*\
*\":u\": { N: String(now) },*\
*\":r\": { N: String(Math.ceil(now/1000 + (b.limit -
remaining)/b.refill)) }*\
*},*\
*ExpressionAttributeNames: { \"#u\": \"updated_at\", \"#r\": \"reset\"
}*\
*}));*\
*return { ok:true, remaining: Math.floor(remaining), reset:
Math.ceil(now/1000 + (b.limit - remaining)/b.refill) };*\
*}*\
\
*export function request(ctx) {*\
*const op = ctx.info.fieldName; // e.g., searchPeople*\
*const sub = ctx.identity?.sub ?? \"anon\";*\
*const ip =
ctx.request?.headers?.\[\"x-forwarded-for\"\]?.split(\",\")\[0\]?.trim()
?? \"0.0.0.0\";*\
\
*const now = Date.now();*\
*let key, limit, refill;*\
*if (op.startsWith(\"search\")) {*\
*if (sub === \"anon\") { key = \`ip#\${ip}#search\`; limit = 60; refill
= 1; } // 60/min*\
*else { key = \`user#\${sub}#search\`; limit = 40; refill = 0.6667; } //
40/min*\
*} else if (op === \"sendMessage\") {*\
*const peer = ctx.args?.input?.peerId ?? \"unknown\";*\
*key = \`dyad#\${\[sub,peer\].sort().join(\":\")}#msg.send\`; limit =
20; refill = 0.3333; // 20/min*\
*} else {*\
*key = \`user#\${sub}#gen\`; limit = 60; refill = 1;*\
*}*\
\
*const bucketState = bucket(now, key, limit, refill);*\
*const res = ctx.util.qr(consume(bucketState, 1));*\
*return res; // result passed to response()*\
*}*\
\
*export function response(ctx) {*\
*const res = ctx.prev.result; // from request()*\
*if (!res.ok) {*\
*ctx.util.error(\`Rate limit exceeded. Retry after \${(res.reset -
Math.ceil(Date.now()/1000))}s\`, \"Throttled\", 429, {*\
*\"Retry-After\": String(Math.max(1, res.reset -
Math.ceil(Date.now()/1000))),*\
*\"X-RateLimit-Limit\": \"n/a\",*\
*\"X-RateLimit-Remaining\": String(res.remaining),*\
*\"X-RateLimit-Reset\": String(res.reset)*\
*});*\
*}*\
*// Attach informative headers on success*\
*ctx.responseOverride = {*\
*headers: {*\
*\"X-RateLimit-Limit\": \"dynamic\",*\
*\"X-RateLimit-Remaining\": String(res.remaining),*\
*\"X-RateLimit-Reset\": String(res.reset)*\
*},*\
*statusCode: 200*\
*};*\
*return ctx.result;*\
*}*\

Bind this **as a pipeline function** before resolvers that need
throttling (search, messaging send, checkout create/confirm,
auth‑adjacent queries). Staff roles can bypass via a conditional.

## **R.5 Keying strategy (what we count)**

- **IP** for unauthenticated endpoints (and suggestions), aggregated to
  **/24** for residential NATs (compute key as *ip#A.B.C.0/24*).
- **userId** for most authenticated operations.
- **dyadId** (*min(userA,userB):max(userA,userB)*) for **messages** to
  limit harassment without blocking legitimate conversa